#!/usr/bin/env pythonfrom numpy import *from scipy import *from pylab import *import pickleimport os, sys#import matplotlib.axes3d as p3def initialize():    init = 12    if init==6:    #   Figure 6 initial conditions        # This is the initialization sequence using hardwired input.        n = 200000            #time interval                m = (469.19*10**6)/(300**2) #reduced mass of H molecule in MeV/c^2                x = zeros(n,dtype=float)        y = zeros(n,dtype=float)            vx = zeros(n,dtype=float)        vy = zeros(n,dtype=float)        fx = zeros(n,dtype=float)        fy = zeros(n,dtype=float)        t = zeros(n,dtype=float)          x[0] = 0.05                #set initial x position (nm)        y[0] = 0.05#0.06                 #set initial y position (nm)        vx[0] = -0.01               #set initial x velocity        vy[0] = 0.01                #set initial y velocity        dt = 0.001                 #timestep in femtoseconds                     elif init==6:    #Figure 5 initial conditions -  almost!        # This is the initialization sequence using hardwired input.        n = 400000            #time interval                m = (469.19*10**6)/(300**2) #reduced mass of H molecule in MeV/c^2                x = zeros(n,dtype=float)        y = zeros(n,dtype=float)            vx = zeros(n,dtype=float)        vy = zeros(n,dtype=float)        fx = zeros(n,dtype=float)        fy = zeros(n,dtype=float)        t = zeros(n,dtype=float)          x[0] = 0.03                #set initial x position (nm)        y[0] = 0.065#0.06                 #set initial y position (nm)        vx[0] = 0.0               #set initial x velocity        vy[0] = 0.0                #set initial y velocity                dt = 0.001                 #timestep in femtoseconds                                         elif init ==7:        #an attempt at a reaction - this initial condition fails to react        # This is the initialization sequence using hardwired input.        n = 127000            #time interval                m = (469.19*10**6)/(300**2) #reduced mass of H molecule in MeV/c^2                x = zeros(n,dtype=float)        y = zeros(n,dtype=float)            vx = zeros(n,dtype=float)        vy = zeros(n,dtype=float)        fx = zeros(n,dtype=float)        fy = zeros(n,dtype=float)        t = zeros(n,dtype=float)          x[0] = 0.55                #set initial x position (nm)        y[0] = 0.05#0.06                 #set initial y position (nm)        vx[0] = -0.01               #set initial x velocity        vy[0] = 0.0                #set initial y velocity                dt = 0.001                 #timestep in femtoseconds                                         elif init==8:        #an attempt at a reaction - this initial condition does not react        # This is the initialization sequence using hardwired input.        n = 72000            #time interval                m = (469.19*10**6)/(300**2) #reduced mass of H molecule in MeV/c^2                x = zeros(n,dtype=float)        y = zeros(n,dtype=float)            vx = zeros(n,dtype=float)        vy = zeros(n,dtype=float)        fx = zeros(n,dtype=float)        fy = zeros(n,dtype=float)        t = zeros(n,dtype=float)          x[0] = 0.55                #set initial x position (nm)        y[0] = 0.075#0.06                 #set initial y position (nm)        vx[0] = -0.01               #set initial x velocity        vy[0] = 0.0                #set initial y velocity                dt = 0.001                 #timestep in femtoseconds                   elif init==9:        #an attempt at a reaction - this initial condition reacts react        # This is the initialization sequence using hardwired input.        n = 170000            #time interval                m = (469.19*10**6)/(300**2) #reduced mass of H molecule in MeV/c^2                x = zeros(n,dtype=float)        y = zeros(n,dtype=float)            vx = zeros(n,dtype=float)        vy = zeros(n,dtype=float)        fx = zeros(n,dtype=float)        fy = zeros(n,dtype=float)        t = zeros(n,dtype=float)          x[0] = 0.55                #set initial x position (nm)        y[0] = 0.1#0.06                 #set initial y position (nm)        vx[0] = -0.01               #set initial x velocity        vy[0] = 0.0                #set initial y velocity                dt = 0.001                 #timestep in femtoseconds    elif init==10:        #an attempt at a reaction - this initial condition reacts react        # This is the initialization sequence using hardwired input.        n = 170000            #time interval                m = (469.19*10**6)/(300**2) #reduced mass of H molecule in MeV/c^2                x = zeros(n,dtype=float)        y = zeros(n,dtype=float)            vx = zeros(n,dtype=float)        vy = zeros(n,dtype=float)        fx = zeros(n,dtype=float)        fy = zeros(n,dtype=float)        t = zeros(n,dtype=float)          x[0] = 0.22                #set initial x position (nm)        y[0] = 0.1#0.06                 #set initial y position (nm)        vx[0] = -0.01               #set initial x velocity        vy[0] = 0.0                #set initial y velocity                dt = 0.001                 #timestep in femtoseconds            elif init==11:        #an attempt at a reaction - this initial condition doesn't react with 2body morse but does with        #the Wall-Porter surface        #        # This is the initialization sequence using hardwired input.        n = 200000            #time interval                m = (469.19*10**6)/(300**2) #reduced mass of H molecule in MeV/c^2                x = zeros(n,dtype=float)        y = zeros(n,dtype=float)            vx = zeros(n,dtype=float)        vy = zeros(n,dtype=float)        fx = zeros(n,dtype=float)        fy = zeros(n,dtype=float)        t = zeros(n,dtype=float)          x[0] = 0.55                #set initial x position (nm)        y[0] = 0.1#0.06                 #set initial y position (nm)        vx[0] = -0.011               #set initial x velocity        vy[0] = 0.0                #set initial y velocity                dt = 0.001                 #timestep in femtoseconds                elif init==12:        #        # This is the initialization sequence using hardwired input.        n =200000           #time interval                m = (469.19*10**6)/(300**2) #reduced mass of H molecule in MeV/c^2                x = zeros(n,dtype=float)        y = zeros(n,dtype=float)            vx = zeros(n,dtype=float)        vy = zeros(n,dtype=float)        fx = zeros(n,dtype=float)        fy = zeros(n,dtype=float)        t = zeros(n,dtype=float)          x[0] = 0.26                #set initial x position (nm)        y[0] = 0.074 + 0.05                 #set initial y position (nm)        vx[0] = -0.002               #set initial x velocity        vy[0] = -0.002                #set initial y velocity                dt = 0.001                 #timestep in femtoseconds            #Notes - to add to this code    #1 - viewport in plotting as part of initial condition    #2 - proper case1, case2, initializations    #3 - Wall porter potential energy surface    return [n,m,x,y,vx,vy,fx,fy,t,dt]def force(z):    """    calculates the force (dV/dz)    """    re = 0.074      #nm    a = 19.3        #nm^-1    D = 4.8         #eV    #force in eV/nm or units of 0.16 nN    dVdz = -2*D*(1-e**(-a*(z-re)))*a*e**(-a*(z-re))    return dVdzdef calculate(n,m,x,y,vx,vy,fx,fy,t,dt):    """    This uses the Euler-Cromer method to integrate over the equations of motion.    It returns AB and BC atomic separation as well as the time interval.    """    forcetype =2 # use wall porter force    t[0] = 0.0    for i in range(0, n-1):        #euler-cromer - compute velocity change first        if forcetype==1:            fx[i] = force(x[i]) + force(x[i]+y[i])            fy[i] = force(y[i]) + force(x[i]+y[i])        elif forcetype==2:            fx[i],fy[i] = WallPorterForce(x[i],y[i])        vx[i+1] = vx[i] + (1.0/m)*(fx[i])*dt  #calculate velocity        vy[i+1] = vy[i] + (1.0/m)*(fy[i])*dt  #calculate velocity        #update position with new velocity        x[i+1] = x[i] + vx[i+1]*dt        y[i+1] = y[i] + vy[i+1]*dt        #print t[i],x[i],y[i]        t[i+1] = t[i] + dt##        checkx = ( ((1.0/m)*(Fx)*dt)/vx[i] )##        checky = ( ((1.0/m)*(Fy)*dt)/vy[i] )##        if checkx > 0.1 or checky >0.1:##            print t[i],x[i],y[i],vx[i],vy[i],Fx,Fy,dt    print "Completed calculation"    return [x,y,vx,vy,fx,fy,t]def morseV(r,dummy):    """    approximate potential energy with the Morse Potential    where D = depth of the potenial well (4.48 eV?) (dissociation energy)    ke = force constant at the bottom of the well    Ve = V(re) = potential at equalibrium    r = distance between the atoms    and re = distance between atoms at equalibrium.    """      D = 4.8         #eV    re = 0.074      #nm    a = 19.3        #nm^-1        V = D*(1- e**(-a*(r-re)))**2        return Vdef WallPorter(x,y):    """    This gives the Wall-Porter PE surface taken from J Chem Phys 36 12 pp3256-3260    Note - in their fig 5 they do not subtract D from the PE surface - their contour plot is    not quite accurate - it is qualitatively reproduced here in a contour, and two surface plots, one showing the    potential barrier to reaction which is 12% of the depth of the Morse potential well    """    R = 0.24 #nm    a = 0.128 # Barrir height as fraction of well depth    x0 = 0.074 #nm    s0 = 0.09416 #nm    alpha0 = 19.4 #nm^-1    alphadagger = 13.0 #nm^-1    D = 4.8 #eV    l = 4.0        V = 0.0    if x<=R and y <=R:        #theta is between 0 and pi/2 so no need for branch stuff - but use arctan2        #to avoid divide by zero problems        theta = arctan2((R-y),(R-x))        gamma = D*(1-a*(sin(2.0*theta)**l) )        alpha= alpha0 + (alphadagger-alpha0)*((sin(2.0*theta))**4.0)        xi = (sqrt(2.0)*(R-s0)-(R-x0))*(sin(2.0*theta)**4) + (R-x0) - (R-x)/cos(theta)        V = gamma*( (1.0-exp(-alpha*xi))**2.0-1)    elif x<R and y>R:        theta = 0.0        gamma = D        alpha= alpha0         xi = x-x0        V = gamma*( (1.0-exp(-alpha*xi))**2.0-1)    elif x>R and y<R:        theta = 0.0        gamma = D        alpha= alpha0         xi = y-x0        V = gamma*( (1.0-exp(-alpha*xi))**2.0-1)    elif x>R and y>R:        #just make the potential constant here?        theta = 0.0        gamma = D        alpha= alpha0         xi = R-x0        V = gamma*( (1.0-exp(-alpha*xi))**2.0-1)                    return Vdef WallPorterForce(x,y):    """    This gives the Wall-Porter Forces derived from the PE surface taken from J Chem Phys 36 12 pp3256-3260    """    R = 0.24 #nm    a = 0.128 # Barrir height as fraction of well depth    x0 = 0.074 #nm    s0 = 0.09416 #nm    alpha0 = 19.4 #nm^-1    alphadagger = 13.0 #nm^-1    D = 4.8 #eV    l = 4.0        V = 0.0    dVdx = 0.0    dVdy = 0.0        if x<R and y <R:        #theta is between 0 and pi/2 so no need for branch stuff        theta = arctan2((R-y),(R-x))                #first calculate derivative of theta with respect to x and y        u = (R-y)/(R-x)        dthdx = (u/(R-x))/(1.0+u**2)        dthdy = -(1/(R-x))/(1.0+u**2)        #now do derivative of xi        dxidx = 8*(sqrt(2.0)*(R-s0)-(R-x0))*(sin(2.0*theta)**3)*cos(2.0*theta)*dthdx + 1.0/cos(theta) - ( (R-x)*sin(theta)/(cos(theta)**2.0) )*dthdx        dxidy = 8*(sqrt(2.0)*(R-s0)-(R-x0))*(sin(2.0*theta)**3)*cos(2.0*theta)*dthdy -( (R-x)*sin(theta)/(cos(theta)**2.0) )*dthdy            #now do derivative of alpha        dalphadx = 8*(alphadagger-alpha0)*(sin(2.0*theta)**3)*cos(2.0*theta)*dthdx        dalphady = 8*(alphadagger-alpha0)*(sin(2.0*theta)**3)*cos(2.0*theta)*dthdy        #now do derivative of gamma        dgammadx = -2.0*a*l*(sin(2.0*theta)**(l-1))*cos(2.0*theta)*dthdx        dgammady = -2.0*a*l*(sin(2.0*theta)**(l-1))*cos(2.0*theta)*dthdy        gamma = D*(1-a*(sin(2.0*theta)**l) )        alpha= alpha0 + (alphadagger-alpha0)*((sin(2.0*theta))**4.0)        xi = (sqrt(2.0)*(R-s0)-(R-x0))*(sin(2.0*theta)**4) + (R-x0) - (R-x)/cos(theta)        V = gamma*( (1.0-exp(-alpha*xi))**2.0-1)                dVdx = dgammadx*V/gamma + gamma*2.0*(1.0-exp(-alpha*xi))*exp(-alpha*xi)*(alpha*dxidx+dalphadx*xi)        dVdy = dgammady*V/gamma + gamma*2.0*(1.0-exp(-alpha*xi))*exp(-alpha*xi)*(alpha*dxidy+dalphady*xi)        #print x,y,R,"bottom left quadrant"    elif x<R and y >= R:        dVdx = 2*D*(1-e**(-alpha0*(x-x0)))*alpha0*exp(-alpha0*(x-x0))        dVdy = 0.00001*D/R # you can't have the force go from zero to nonzero suddenly - E_C method screws up by producing a constant velocity        #print x,y,R,"top left quadrant"    elif x >= R and y<=R:        dVdx = 0.00001*D/R # you can't have the force go from zero to nonzero suddenly        dVdy = 2*D*(1-e**(-alpha0*(y-x0)))*alpha0*exp(-alpha0*(y-x0))        #print x,y,R,"bottom right quadrant"    elif x>=R and y > R:        dVdx = 2*D*(1-e**(-alpha0*(x-x0)))*alpha0*exp(-alpha0*(x-x0))        dVdy = 2*D*(1-e**(-alpha0*(y-x0)))*alpha0*exp(-alpha0*(y-x0))         #print x,y,R,"top right quadrant"    return -dVdx,-dVdydef PlotWallPorter():    """    This gives the Wall-Porter PE surface taken from J Chem Phys 36 12 pp3256-3260    Note - in their fig 5 they do not subtract D from the PE surface - their contour plot is    not quite accurate - it is qualitatively reproduced here in a contour, and two surface plots, one showing the    potential barrier to reaction which is 12% of the depth of the Morse potential well    """    LX = 0.5    LY = 0.5    dx = 0.011    dy = 0.011    D = 4.8    fxcomp = 0.0    fycomp = 0.0    NX = int(LX/dx)    NY = int(LY/dy)    V = zeros((NX,NY),dtype=float)    FX = zeros((NX,NY),dtype=float)    FY = zeros((NX,NY),dtype=float)    VPlot = zeros((NX,NY),dtype=float)    xr = zeros(NX,dtype=float)    yr = zeros(NY,dtype=float)    xy = zeros(NX,dtype=float)    for ii in range(NX):        for jj in range(NY):            x = ii*dx            y = jj*dy                        V[ii,jj] = WallPorter(x,y)            fxcomp,fycomp = WallPorterForce(x,y)            FX[ii,jj] = fxcomp            FY[ii,jj] = fycomp            #don't include the values             if V[ii,jj]>D/10.0:                VPlot[ii,jj]=0.0 #               FX[ii,jj] = 0.0 #               FY[ii,jj] = 0.0            else:                VPlot[ii,jj] = V[ii,jj]            xr[ii] = x            yr[jj] = y    for kk in range(NX):        xy[kk] = V[kk,kk]    #check symmetry    print sum(V-V.transpose())    #now do the plotting    #First plot the contours with a vector field of forces superimposed    fig = figure(figsize=(20,20))    ax = fig.add_subplot(111)    clevels = arange(-1,1,0.1)*D    cont=ax.contour(xr,yr,VPlot,levels = clevels)    #now label the contour plot    ax.clabel(cont, inline=1, fontsize=10)    #create an array to convert the vectors into unit vectors    norm = sqrt(FX*FX + FY*FY)    print norm    #want to mask all the zero values in norm so we can divide without getting div by zero errors.    for pp in range(NX):        for qq in range(NY):            if norm[pp,qq] == 0.0:                norm[pp,qq] = 1.0    xlabel("Separation between atoms A and B (nm)")    ylabel("Separation between atoms B and C (nm)")    #quiver(xr,yr,FX.transpose()/norm,FY.transpose()/norm)####    #fig=figure()        #clevels = array([0.0,0.01,0.02,0.03,0.05,0.1,0.3,0.4,0.5])*D #contours as in Fig 5 of Wall and Porter    #ax = p3.Axes3D(fig)    #ax.contour3D(xr,yr,VPlot)#FORCES##    fig3=figure()####    print min(FX.reshape(NX*NY))##    clevels= arange(min(FX.reshape(NX*NY)),max(FX.reshape(NX*NY)),abs(max(FX.reshape(NX*NY))-min(FX.reshape(NX*NY)))/200.0)##    print min(FX.reshape(NX*NY)),max(FX.reshape(NX*NY))#,max(FX),abs(max(FX)-min(FX))/20.0,clevels##    ax3 = p3.Axes3D(fig3)##    ax3.contour3D(xr,yr,FX,levels=clevels)##    fig4=figure()##    clevels= arange(min(FY.reshape(NX*NY)),max(FY.reshape(NX*NY)),abs(max(FY.reshape(NX*NY))-min(FY.reshape(NX*NY)))/200.0)##    print min(FY.reshape(NX*NY)),max(FY.reshape(NX*NY))##    ax4 = p3.Axes3D(fig4)##    ax4.contour3D(xr,yr,FY,levels=clevels)    show()    def plotcolinearV(x,y,forcetype):    """    Plot a contour plot of the Morse approximated potential    of the colinear instance of a three body system.    nx = number of x points    ny =  number of y points    """      Lx = 0.5    Ly = 0.5    dx = 0.0011    dy = 0.0011    nx = int(Lx/dx)    ny = int(Lx/dy)    D = 4.8    varray = zeros((nx, ny),dtype=float)    for r in range(0,nx):         for ss in range(0,ny):            x=r*dx            y=ss*dy            if forcetype==1:                varray[r,ss] = morseV(x,0) + morseV(y,0) + morseV(x+y,0)            elif forcetype ==2:                varray[r,ss] = WallPorter(x,y)                    xr = arange(0.0,Lx,Lx/nx)    yr = arange(0.0,Ly,Ly/ny)    return xr,yr,varraydef graph(x,y,t,fx,fy,xr,yr,varray,flag):    """    Plots graphs of motion and potential    flag =1 throw up a plot of the whole trajectory    flag =2 make a movie.    """    if flag==1:        #plot a contour of the potential well        figure (1)        contour(xr,yr,varray,50)        plot(x,y,'k')        xlim(0.0,0.5)        ylim(0.0,0.5)        xlabel('Separation Between Atoms A and B (nm)')        ylabel('Separation Between Atoms C and B (nm)')        nn = len(t)        figure(2)        plot(t,fx[0:nn],'r')        xlabel('t')        ylabel('fx')        figure(3)        plot(t,fy[0:nn],'b')        xlabel('t')        ylabel('fy')        figure(4)        plot(x,fx[0:nn],'r')        xlabel('x')        ylabel('fx')        figure(5)        plot(x,fy[0:nn],'b')        xlabel('x')        ylabel('fy')        figure(6)        plot(y,fx[0:nn],'r')        xlabel('y')        ylabel('fx')        figure(7)        plot(y,fy[0:nn],'r')        xlabel('y')        ylabel('fy')        show()    else:        n = len(x)        files = []        fig = figure(figsize=(5,5))        ax = fig.add_subplot(111)        framestep = 1000        for tt in range(n/framestep):                ax.cla()                cont=ax.contour(xr,yr,varray,50)                #now label the contour plot                ax.clabel(cont, inline=1, fontsize=10)                ax.plot(x[0:tt*framestep],y[0:tt*framestep],'k')                xlim(0.0,0.4)                ylim(0.0,0.4)                xlabel('Separation Between Atoms A and B (nm)')                ylabel('Separation Between Atoms C and B (nm)')                fname = '_tmp%03d.png'%tt                print 'Saving frame', fname                # fig.savefig(fname)                # files.append(fname)                # show(fig)        show(fig)                print 'Making movie animation.mpg - this make take a while'        # os.system("mencoder 'mf://_tmp*.png' -mf type=png:fps=10 -ovc lavc -lavcopts vcodec=wmv2 -oac copy -o animation.mpg")def check():    """    Check butt joint of different potential regions    """    for ii in range(200):        x = 0.25 -  ii*0.001        y =0.12        print x,y        fxcomp,fycomp = WallPorterForce(x,y)        print x,y,fxcomp, fycomp        def main(flag):    """    Actually runs everything    """    [n,m,x,y,vx,vy,fx,fy,t,dt] = initialize()    [x,y,vx,vy,fx,fy,t] = calculate(n,m,x,y,vx,vy,fx,fy,t,dt)##    figure(1)##    plot(t,x,'b')##    figure(2)##    plot(t,y,'r')##    show()    xr,yr,varray = plotcolinearV(x,y,2)    graph(x,y,t,fx,fy,xr,yr,varray,flag)#note - for any potential energy you need to get the contour + vector plot#working first - if this doesn't work you probably have nans in your forcesmain(2)# PlotWallPorter()#check()